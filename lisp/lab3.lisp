;lab3
;#3
    ;Определите предикат, проверяющий:
    ;3) Являются ли два множества пересекающимися

(defun member2 (x L)
    (cond
        ((null L) nil)
        ; список пуст = элемента нет
        ((equal x (car L)) t)
        ; голова это искомый элемент = элемент есть
        (t (member2 x (cdr L)))
        ; рекурсия
    )
)

(defun peres (M1 M2)
    (cond
        ((null M1) nil)
        ; М1 пустое = не пересекаются
        ((member2 (car M1) M2) t)
        ; голова M1 входит в M2 = пересекаются
        (t (peres (cdr M1) M2))
        ; входим в рекурсию, если М1 не пустое и не пересекается
    )
)

(print (peres '(0 1 2 3) '(4 5 6 7)))
(print (peres '(0 1 2 3) '(3 4 5 6)))



;#6
    ;Определите функцию:
    ;6) Возвращающую разность двух множеств, т.е. множество из элементов первого
    ;множества, не входящих во второе

(defun razn (M1 M2)
    (cond
        ((null M1) nil)
        ; M1 пустое?
        ((member2 (car M1) M2) (razn (cdr M1) M2))
        ; голова M1 есть в M2 => элемент не записываем, идем дальше
        (t (cons (car M1) (razn (cdr M1) M2)))
        ; головы M1 нет в M2 => элемент записываем, идем дальше
    )
)

(print (razn '(0 1 2 3) '(4 5 6 7)))
(print (razn '(0 1 2 3) '(3 4 5 6)))



;#11
    ;Определите функционал:
    ;11) Выполняющий определенную операцию над соответствующими элементами двух
    ;списков (Используйте применяющий функционал FUNCALL). Проверьте работу
    ;функционала для операций:
        ;- выбор максимального элемента (функциональный аргумент – лямбда выражение);
        ;- деление (функциональный аргумент – имя встроенной функции /).

(defun funcional (f L1 L2)
    (cond
        ((null L1) nil)
        ((null L2) nil)
        ; пустые ли списки?
        (t (cons (funcall f (car L1) (car L2)) (funcional f (cdr L1) (cdr L2))))
        ; вызываем функцию и вставляем результат в список + входим в рекурсию
    )
)

(print (funcional (lambda (x y) (if (> x y) x y)) '(4 1 7 3) '(4 5 6 7)))
(print (funcional #'/ '(4 2 6 9) '(2 2 2 9)))
